from __future__ import annotations

from collections import Counter
from functools import reduce
from math import ceil, floor
from multiprocessing import Pool
from typing import Any, Callable, Dict, Iterable

import pytest

from cuid2 import Cuid


def cuid_generator(max_ids: int) -> Dict[str, Any]:
    """Generate a specified number of unique IDs using the CUID library and return a dictionary containing
    information about the generated IDs.

    Parameters
    ----------
    max_ids : int
        The maximum number of unique IDs to generate.

    Returns
    -------
    dict[str, Any]
        a dictionary containing three keys: "ids", "id_histogram", and "char_histogram".
        The "ids" key contains a set of unique CUIDs generated by the function.
        The "id_histogram" and "char_histogram" keys contains a Counter object that counts the
        frequency of each bucket in which the CUIDs fall
    """
    str_base: int = 36

    def _id_to_int(value: str, radix: int = str_base) -> int:
        return reduce(lambda r, v: r * radix + int(v, radix), value, 0)

    cuid: Callable[[], str] = Cuid().generate
    bucket_count: int = 20

    result: dict[str, Any] = {
        "ids": set(),
        "id_histogram": Counter(),
        "char_histogram": Counter(),
    }

    bucket_length: int = ceil(str_base**23 / bucket_count)

    for _ in range(max_ids):
        uid: str = cuid()
        result["ids"].add(uid)
        result["id_histogram"][_id_to_int(uid[1:]) // bucket_length] += 1
        for char in uid[1:]:
            result["char_histogram"][char] += 1

    return result


def is_histogram_evenly_distributed(
    histogram_values: Iterable[int],
    expected_bin_size: int,
    tolerance: float = 0.04,
) -> bool:
    """Check if the values in a histogram are evenly distributed within a certain tolerance range.

    Parameters
    ----------
    histogram_values : Iterable[int]
        An iterable of integers representing the counts of items in each bin of a histogram.
    expected_bin_size : int
        The expected size of each bin in the histogram.
    tolerance : float
        The tolerance parameter is a float value that determines the acceptable range of deviation from the expected
        bin size. It is used to determine whether the histogram is evenly distributed or not. If the difference
        between the actual bin size and the expected bin size is within the tolerance range,
        the histogram is considered to be evenly distributed.

    Returns
    -------
    bool
        indicates whether the histogram values are evenly distributed within a certain tolerance range.
    """
    min_bin_size: int = floor(expected_bin_size * (1 - tolerance))
    max_bin_size: int = ceil(expected_bin_size * (1 + tolerance))
    return all(min_bin_size < count < max_bin_size for count in histogram_values)


@pytest.mark.slow()
@pytest.mark.parametrize(
    ("num_ids", "num_pools"),
    [
        (1_000_000, 1),  # 1 million total ids, distributed across a single pool (~40 seconds)
        (100_000, 10),  # 1 million total ids, distributed across 10 pools (~10 seconds)
        (10_000, 100),  # 1 million total ids, distributed across 100 pools (~12 seconds)
        (10_000_000, 10),  # 100 million total ids, distributed across 10 pools (~18 minutes)
        (1_000_000, 100),  # 100 million total ids, distributed across 100 pools (~18 minutes)
    ],
)
def test_collisions(num_ids: int, num_pools: int) -> None:
    """Test for collisions, character representation, even character frequency, and histogram distribution
    tolerance in a CUID generator.

    Parameters
    ----------
    num_ids : int
        The number of unique IDs to generate in each pool.
    num_pools : int
        The `num_pools` parameter represents the number of worker processes to use in parallel for generating CUIDs.
    """
    total_num_ids: int = num_ids * num_pools
    with Pool(num_pools) as pool:
        result = pool.map(cuid_generator, (total_num_ids // num_pools,) * num_pools)

    # should: generate no collisions
    assert len(set.union(*[r["ids"] for r in result])) == total_num_ids

    # should: represent all 36 character values
    for r in result:
        assert len(r["char_histogram"].keys()) == 36

    # should: produce even character frequency
    sum_char_histograms: Counter = sum((r["char_histogram"] for r in result), Counter())
    expected_char_bin_size: int = ceil((23 * total_num_ids) / 36)
    assert is_histogram_evenly_distributed(sum_char_histograms.values(), expected_char_bin_size)

    # should: produce a histogram with even distribution tolerance
    sum_id_histograms: Counter = sum((r["id_histogram"] for r in result), Counter())
    expected_id_bin_size: int = ceil(total_num_ids / len(sum_id_histograms.keys()))
    assert is_histogram_evenly_distributed(sum_id_histograms.values(), expected_id_bin_size)
